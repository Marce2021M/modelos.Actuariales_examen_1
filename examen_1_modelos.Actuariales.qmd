---
title: "Modelos Actuariales"
subtitle: "Actuarial 3"
lang: es
author: "Marcelino Sánchez"
date: today
format:
  html:
    page-layout: full
    embed-resources: true
  pdf: 
     include-in-header:  
        - text: |
            \usepackage{actuarialsymbol}
            \usepackage{booktabs}
            \usepackage{float}
     embed-resources: true
editor_options: 
  chunk_output_type: console
---


```{r, echo=FALSE, results=FALSE, warning=FALSE, message=FALSE}
# Cargamos la libreria
library(readxl)
library(ggplot2)
library(dplyr)
library(tidyverse)

# Supuestos principales
# 191654
# edad del asegurado
xEdad <- 16+30
#vigencia del seguro
n <- 19
#tasa de interes efectiva anual
itasaBase <- .05
#numero de primas anuales
mPrimas <- 4
# Sumas aseguradas
saMuerte <- 2000000
saSupervivencia <- 1000000

nCarteraAsegurados <- 100

# Leeremos la tabla de mortalidad

# Leemos la tabla de mortalidad
tablaMortalidad <- read_excel("Tabla_mortalidad.xlsx")

tablaMortalidad <- tablaMortalidad |> 
  mutate(dx= c(tablaMortalidad$lx[1:(length(tablaMortalidad$lx)-1)]-tablaMortalidad$lx[2:length(tablaMortalidad$lx)],NA))

qTablaMortalidad <- data.frame(px = numeric(length(tablaMortalidad$lx)-xEdad), kSuperv = numeric(length(tablaMortalidad$lx)-xEdad))


# Creamos la columna de supervivencia

for(i in (xEdad+1):length(tablaMortalidad$lx)){
  qTablaMortalidad$px[i-xEdad] <- tablaMortalidad$lx[i]/tablaMortalidad$lx[xEdad+1] 
  qTablaMortalidad$kSuperv[i-xEdad] <- i-xEdad-1
}

######-------------------------------------
#Gastos base

# Hacemos función de gastos extras

gastosExtrasPrimas <- function(anio){
  if(anio == 0){
    return(1000 + primaEmision*.4)
  }else if(anio %in% c(1,2)){
    return(500+.2*primaEmision)
  }else {
    return(100 + .05*primaEmision)
  }
}

gastosExtrasLiquidacion <- function(salida){
  if(salida == "muerte"){
    return(3000 + saMuerte*.003)
  }else{
    return(1000+saSupervivencia*.001)
}}

######-------------------------------------
#Regla de valores garantizados

# Hacemos función de valores garantizados

valoresGarantizados <- function(valorPoliza, anio){
  if(anio %in% c(1,2)){
    return(valorPoliza*.8)
  }else if (anio == 3){
    return(valorPoliza*.9)
  } else {
    return(0)
  }
}


```

# Nota Técnica

## 1. Descripción de la cobertura del seguro

### a. Tipo de seguro

Es un seguro dotal mixto.

### b. Temporalidad

El seguro tiene una vigencia de `r n` años con primas niveladas por 4 años anticipadamente.

### c. Población asegurada

La edad de los asegurados es de `r xEdad` años.

## 2. Hipótesis demográficas y financieras

### a. Hipótesis demográfica

Utilizaremos la tabla proporcionada por la aseguradora. La cual para una persona de `r xEdad` años se ve de la siguiente manera:

```{r,  echo=FALSE}
              
# Graficamos la tabla

ggplot(qTablaMortalidad, aes(x = kSuperv, y = px)) +
  geom_line() +
  geom_point() +
  labs(title = "Tabla de mortalidad", x = "Supervivencia", y = "px") 
```

### b. Hipótesis sobre costos

Dados los valores observados por la aseguradora tendremos los siguientes gastos.

Los gastos asociados a la prima son \$1000 más 40% de la prima en la emisión, \$500 más 20% de la prima los siguientes dos años y \$100 más 5% de la prima para el resto de los años donde se paga prima. Los gastos asociados a la liquidación son \$3,000 mas 0.3% de la suma asegurada en caso de muerte y \$1,000 mas 0.1% de la suma asegurada en caso de supervivencia.

### c. Hipótesis sobre tasa de interés

La tasa base será del `r itasaBase*100`%, porque actualmente existe la expectativa de disminución en la tasa de interés. Esto debido a que la inflación está disminuyendo, y la política de BM es bajar las tasas de interés una vez controlada la inflación. Además, como el seguro tiene una vigencia de `r n` años esperamos que disminuya aún más manteniendose en promedio del `r itasaBase*100`%.

## 3. Procedimientos técnicos

```{r echo=FALSE, results=FALSE}
# Funciones útiles para los siguientes cálculos

# Definición de más variables globales

v <- 1/(1+itasaBase)

# Cálculo de temporales

temporal <- function(edad, vigencia){
  resultado <- 0
  for (k in seq(0, vigencia-1, 1)){
    resultado <- resultado + v^(k+1)*(tablaMortalidad$dx[edad+k+1]/tablaMortalidad$lx[edad+1])
  }
  return(resultado)
}

anualidad <- function(edad, vigencia){
  resultado <- 0
  for (k in seq(0, vigencia-1, 1)){
    resultado <- resultado + v^(k)*(tablaMortalidad$lx[edad+k+1]/tablaMortalidad$lx[edad+1])
  }
  return(resultado)
}

dotal <- function(edad, vigencia){
  resultado <- v^(vigencia)*tablaMortalidad$lx[xEdad+vigencia+1]/tablaMortalidad$lx[xEdad+1]
  return(resultado)
}

valorPoliza <- function(kTemp, prima){
  resultado <- 0
  if(kTemp %in% c(1,2,3,4)){
    resultado <- (dotal(xEdad,kTemp)^(-1))*(prima*anualidad(xEdad,kTemp)-saMuerte*temporal(xEdad, kTemp))
  } 
  else if(kTemp >=5 && kTemp<=n){
    resultado <- (dotal(xEdad,kTemp)^(-1))*(prima*anualidad(xEdad,4)-saMuerte*temporal(xEdad, kTemp))}
  else{
    resultado <- 0
  }
}

valorPolizaRecargado <- function(kTemp, primaRecargada){
  resultado <- 0
  if(kTemp == 1){
    resultado <- (dotal(xEdad,kTemp)^(-1))*(-1000+.6*primaRecargada-(3000+1.003*saMuerte)*temporal(xEdad, kTemp))
  } 
  else if(kTemp %in% c(2,3)){
    resultado <- (dotal(xEdad,kTemp)^(-1))*(-1000+.6*primaRecargada+(-500+.8*primaRecargada)*(anualidad(xEdad, kTemp)-1)-(3000+1.003*saMuerte)*temporal(xEdad, kTemp))
  }
  else if(kTemp >=4 && kTemp<=n){
    resultado <- (dotal(xEdad,kTemp)^(-1))*(-1000+.6*primaRecargada+(-500+.8*primaRecargada)*(anualidad(xEdad, 3)-1)+(-100+.95*primaRecargada)*anualidad(xEdad+3, mPrimas-3)*dotal(xEdad, 3)-(3000+1.003*saMuerte)*temporal(xEdad, kTemp))
  }
  else{
    resultado <- 0
  }
  return (resultado)
}


```


### a. Prima neta

(Fórmula para el cálculo y valor obtenido)

La prima neta está dada por la siguiente fórmula:

$$P=\frac{(SA_M)A_{`r xEdad`:\angl{`r n`}} +(SA_S) \Ex[`r n`]{`r xEdad`} }{\ddot{a}_{`r xEdad`:\angl{`r mPrimas`}}}$$

$$=\frac{(SA_M)(\sum_{k=0}^{`r n-1`}v^{k+1}\frac{\dx{`r xEdad`+k}}{\lx{`r xEdad`}})+(SA_S) v^{`r n`}\frac{\lx{`r xEdad + n`}}{\lx{`r xEdad`}}}{\sum_{k=0}^{`r n-1`}v^{k}\frac{\lx{`r xEdad`+k}}{\lx{`r xEdad`}}}$$

```{r echo=FALSE, results=FALSE}
# Cálculo de la prima neta

primaNeta <- (saMuerte*temporal(xEdad, n) + saSupervivencia*dotal(xEdad,n))/anualidad(xEdad, mPrimas)

```

Con lo cual el valor de la prima neta es de \$`r primaNeta`.

### b. Prima recargada

(Fórmula para el cálculo y valor obtenido)

El valor de la prima recargada proviene de despejar G de la siguiente ecuación:

$$(3000+(1.003)(SA_M))A_{\nthtop*{1}{`r xEdad`}:\angl{`r n`}} + (1000 + (1.001)(SA_S))\Ex[`r n`]{`r xEdad`}= $$

$$-1000+.6G+(-500+.8G)(\ax**{`r xEdad`:\angl{3}}-1)+(-100+.95G)\ax**{`r xEdad+3`:\angl{`r mPrimas-3`}}(\Ex[3]{`r n-3`})$$



Es decir, tenemos que:

$$G= \frac{(3000+(1.003)(SA_M))A_{\nthtop*{1}{`r xEdad`}:\angl{`r n`}} + (1000 + (1.001)(SA_S))\Ex[`r n`]{`r xEdad`}+1000+500((\ax**{`r xEdad`:\angl{3}}-1))+100(\ax**{`r xEdad+3`:\angl{`r mPrimas-3`}})(\Ex[3]{`r xEdad`})}{.6+.8(\ax**{`r xEdad`:\angl{3}}-1)+.95\ax**{`r xEdad+3`:\angl{`r mPrimas-3`}}(\Ex[3]{`r xEdad`})}$$



```{r echo=FALSE, results=FALSE}
# Cálculo de la prima recargada

primaRecargada <- ((3000+1.003*saMuerte)*temporal(xEdad, n) + (1000+1.001*saSupervivencia)*dotal(xEdad,n) + 1000 + 500*(anualidad(xEdad, 3)-1) + 100*anualidad(xEdad+3, mPrimas-3)*dotal(xEdad, 3))/(.6+.8*(anualidad(xEdad, 3)-1)+.95*anualidad(xEdad+3, mPrimas-3)*dotal(xEdad, 3))
```


Con lo cual el valor de la prima recargada es de \$`r primaRecargada`.

### c. Valores póliza asociados a la prima neta

(Fórmula para el cálculo y valores obtenidos para toda la vigencia de la póliza)

Para $k=0,...,4$
$$\Vx[k]{`r xEdad`: \angl{`r n`}}= \frac{1}{\Ex[k]{`r xEdad`}}(P\ax**{`r xEdad`:\angl{k}}-(SA_M)A_{\nthtop*{1}{`r xEdad`}:\angl{k}})$$

Para $k=5,...,`r n`$
$$\Vx[k]{`r xEdad`: \angl{`r n`}}= \frac{1}{\Ex[k]{`r xEdad`}}(P\ax**{`r xEdad`:\angl{4}}-(SA_M)A_{\nthtop*{1}{`r xEdad`}:\angl{k}})$$



```{r echo=FALSE}
# Cálculo de valores póliza asociados

# Creamos la tabla de valores póliza asociados a la prima neta

tablaValoresPolizaAsociados <- data.frame(k = numeric(n+1), Vx = numeric(n+1))

# Llenamos la tabla

for (k in seq(0, n, 1)){
  tablaValoresPolizaAsociados$Vx[k+1] <- valorPoliza(k, primaNeta)
  tablaValoresPolizaAsociados$k[k+1] <- k
}

#Mostramos la tabla

tablaValoresPolizaAsociados 


# Graficamos la tabla

ggplot(tablaValoresPolizaAsociados, aes(x = k, y = Vx)) +
  geom_line() +
  geom_point() +
  labs(title = "Valores póliza asociados a la prima neta", x = "k", y = "Vx") 

```


### d. Valores póliza asociados a la prima recargada

(Fórmula para el cálculo y valores obtenidos para toda la vigencia de la póliza)

Para $k=1$

$$\Vx[k]{`r xEdad`: \angl{`r n`}}= \frac{1}{\Ex[k]{`r xEdad`}}(-1000+.6G-(3000+1.003SA_M)A_{\nthtop*{1}{`r xEdad`}:\angl{k}})$$

Para $k=2,3$

$$\Vx[k]{`r xEdad`: \angl{`r n`}}= \frac{1}{\Ex[k]{`r xEdad`}}(-1000+.6G+(-500+.8G)(\ax**{`r xEdad`:\angl{k}}-1)-(3000+1.003SA_M)A_{\nthtop*{1}{`r xEdad`}:\angl{k}})$$


Para $k=4,...,`r n`$

$$\Vx[k]{`r xEdad`: \angl{`r n`}}= \frac{1}{\Ex[k]{`r xEdad`}}(-1000+.6G+(-500+.8G)(\ax**{`r xEdad`:\angl{3}}-1)+(-100+.95G)(\ax**{`r xEdad+3`:\angl{`r mPrimas-3`}})(\Ex[3]{`r xEdad`})$$
$$-(3000+1.003SA_M)A_{\nthtop*{1}{`r xEdad`}:\angl{k}})$$


```{r echo=FALSE}

# Creamos la tabla de valores póliza asociados a la prima recargada

tablaValoresPolizaAsociadosRecargada <- data.frame(k = numeric(n+1), Vx = numeric(n+1))

# Llenamos la tabla

for (k in seq(0, n, 1)){
  tablaValoresPolizaAsociadosRecargada$Vx[k+1] <- valorPolizaRecargado(k, primaRecargada)
  tablaValoresPolizaAsociadosRecargada$k[k+1] <- k
}

#Mostramos la tabla

tablaValoresPolizaAsociadosRecargada


# Graficamos la tabla

ggplot(tablaValoresPolizaAsociadosRecargada, aes(x = k, y = Vx)) +
  geom_line() +
  geom_point() +
  labs(title = "Valores póliza asociados a la prima recargada", x = "k", y = "Vx") 

```




### e. Valores garantizados

(Fórmula para el cálculo y valores obtenidos mientras haya pago de primas)

Calculado retrospectivamente obtenemos la siguiente fórmula:


Los valores garantizados para la prima neta son:

```{r echo=FALSE}
# Creamos la tabla de valores garantizados

tablaValoresGarantizados <- data.frame(k = numeric(3), Vx = numeric(3))

# Llenamos la tabla

for (k in seq(1, 3, 1)){
  tablaValoresGarantizados$Vx[k] <- valoresGarantizados(valorPoliza(k, primaNeta), k)
  tablaValoresGarantizados$k[k] <- k
}

#Mostramos la tabla

tablaValoresGarantizados


# Graficamos la tabla

ggplot(tablaValoresGarantizados, aes(x = k, y = Vx)) +
  geom_line() +
  geom_point() +
  labs(title = "Valores garantizados", x = "k", y = "Vx") 

```


Los valores garantizados para la prima recargada son:

```{r echo=FALSE}
# Creamos la tabla de valores garantizados

tablaValoresGarantizadosRecargada <- data.frame(k = numeric(3), Vx = numeric(3))

# Llenamos la tabla

for (k in seq(1, 3, 1)){
  tablaValoresGarantizadosRecargada$Vx[k] <- valoresGarantizados(valorPolizaRecargado(k, primaNeta), k)
  tablaValoresGarantizadosRecargada$k[k] <- k
}

#Mostramos la tabla

tablaValoresGarantizadosRecargada


# Graficamos la tabla

ggplot(tablaValoresGarantizadosRecargada, aes(x = k, y = Vx)) +
  geom_line() +
  geom_point() +
  labs(title = "Valores garantizados", x = "k", y = "Vx") 

```

# Profit testing

## 1. Análisis determinista

```{r, echo=F, results=F}

gastoPropPrima <- function(kTemp){
  #Es el complemento del ejerccio por cómo está configurado
  if(kTemp==1){
    resultado <- .6
  } else if(kTemp %in% c(2,3)){
    resultado <- .8
  }else if(kTemp>=4){
    resultado <- .95
  }
  return(resultado)
}
gastoFijoPrima <- function(kTemp){
    if(kTemp==1){
    resultado <- 1000
  } else if(kTemp %in% c(2,3)){
    resultado <- 500
  }else if(kTemp>=4){
    resultado <- 100
  }
  return(resultado)
}

desembolsoProp <- function(salida="Muerte"){
  if(salida =="Muerte"){
    resultado <- 1.003
  } else {
    resultado <- 1.001
  }
  return(resultado)
}
desembolsoFijo <- function(salida="Muerte"){
  if(salida =="Muerte"){
    resultado <- 3000
  } else {
    resultado <- 1000
  }
  return(resultado)
}


flujos_utilidad <- function(kTemp){
  #ktemo solo está entre 1 a n
  if (kTemp %in% c(1,2,3,4)){
    ingreso <- (gastoPropPrima(kTemp)*primaRecargada - gastoFijoPrima(kTemp) + tablaValoresPolizaAsociadosRecargada$Vx[kTemp])*(1+iTasaEstimada)*(tablaMortalidadEstimada$lx[xEdad+kTemp]/tablaMortalidadEstimada$lx[xEdad+1])
    } 
    else {
    ingreso <- tablaValoresPolizaAsociadosRecargada$Vx[kTemp]*(1+iTasaEstimada)*(tablaMortalidadEstimada$lx[xEdad+kTemp]/tablaMortalidadEstimada$lx[xEdad+1])
    }

    egreso <-(desembolsoFijo()+desembolsoProp()*saMuerte)*(tablaMortalidadEstimada$dx[xEdad+kTemp]/tablaMortalidadEstimada$lx[xEdad+1])

    reserva <- tablaValoresPolizaAsociadosRecargada$Vx[kTemp+1]*(tablaMortalidadEstimada$lx[xEdad+kTemp+1]/tablaMortalidadEstimada$lx[xEdad+1])

    resultado <- 100*round(ingreso-egreso-reserva, digits = 9)
    return(resultado)
}

#------ Tabla de Mortalidad Estimada
generate_mortality_table_gamma <- function(alpha, start_age = 46, l_start = 10000, max_age = 101, beta = 1/4) {
  # Vector de edades
  ages <- start_age:max_age
  
  # Calcula la función de supervivencia gamma para cada edad
  Sx <- 1 - pgamma(ages - start_age, shape = alpha, rate = beta)
  
  # Calcula lx basado en la función de supervivencia
  lx <- l_start * Sx
  
  # Calcula dx
  dx <- -c(diff(lx), NA) # Agregamos NA al final porque no hay dx para la última edad
  
  # Crear data.frame para la tabla de mortalidad
  mortality_table <- data.frame(Age = ages, lx = lx, dx = dx)
  
  # Agregar filas con NA hasta el inicio
  na_rows <- data.frame(Age = (0):(start_age-1), lx = rep(NA, start_age), dx = rep(NA, start_age))
  mortality_table <- rbind(na_rows, mortality_table)
  
  return(mortality_table)
}

```

### a. Hipótesis demográficas y financieras

(Elige las variables a analizar, mínimo 2, y los supuestos realistas que vas a utilizar)

Vamos a analizar las variables de tasa de interés y de tabla de mortalidad y sus efectos en las medidas de VPN y MU. 

Nuestro mejor estimador de estas variables es que la tasa de interés con la que traeremos a valor presente todos los flujos será de 7.5%, porque se espera que las tasas  de interés bajen paulatinamente y considerando que actualmente nos encontramos con tasas altísimas del 11% aproximadamente.

Así mismo consideramos que la tabla de mortalidad será una $Gamma(8, 1/4)$, esto porque suponemos que la tala de mortalidad se comporta como una normal y queremos además modelar mayores sobrevivientes que llegan a tener 100 años.

Esta gráfica se ve la siguiene forma:

```{r, echo=F}
iTasaEstimada <- .075
tablaMortalidadEstimada <- generate_mortality_table_gamma(8)

# Gráfico
ggplot(data = tablaMortalidadEstimada, aes(x = Age, y = lx/10000)) +
  geom_line(na.rm = TRUE) +
  labs(title = paste("Tabla de Mortalidad estimada"),
       x = "Edad",
       y = "lx") +
  theme_minimal()+
  coord_cartesian(xlim = c(46, max(tablaMortalidadEstimada$Age)))
```

### b. Valor Presente Neto (VPN)

(Fórmula para el cálculo y valor obtenido)

$$VPN(r) = \sum_{k=1}^{19}F_{k}v^{k}_{r}$$

donde $F_{k}$ representa los flujos vencidos de cada año (solo durante ese año) hasta la vigencia, tomando en cuenta el final de la vigencia. 

Es decir $F_{k} = Ingreso_{k}(1+i^{*}) - Egreso_{k} - Reserva_{k}$

Donde 

$Ingreso_{k}(1+i^{*})$: es el ingreso (menos gatos) y la reserva obtenidas al inicio del año y traídas a valor futuro que corresponde al final del año con la tasa de costo de capital.(CHECAR)

$Egreso_{k}$: es el egreso obtenido al final del año (por muertes).

$Reserva_{k}$: es la reserva que se debe componer al final del año.

```{r, echo=F, results=F}

medidaVPN <- function(rCC=.16){
   #ktemo solo está entre 1 a n
  v <- 1/(1+rCC)
  resultado <- 0
  for (kTemp in seq(1,n,1)){
    resultado <- resultado + flujos_utilidad(kTemp)*v^(kTemp)
  }
  return(resultado)
}
```

Con lo que con las hipótesis planteadas obtenemos un VPN de \$`r medidaVPN()`.


### c. Margen de Utilidad (MU)

(Fórmula para el cálculo y valor obtenido)

$$MU(r) = \frac{VPN(r)}{\sum_{k=1}^{19}R_{k}v^{k}_{r}}$$

```{r, echo=F, results=F}
# Cuidado con kTemp, está trasladado
revenues <- function(kTemp){
  resultado <- (gastoPropPrima(kTemp)*primaRecargada - gastoFijoPrima(kTemp) + tablaValoresPolizaAsociadosRecargada$Vx[kTemp])*(tablaMortalidadEstimada$lx[xEdad+kTemp]/tablaMortalidadEstimada$lx[xEdad+1])
  return(resultado*100)
}

medidaMU <- function(rCC=.16){
  v <- 1/(1+rCC)
  resultado <- 0
  for (kTemp in seq(1,n,1)){
    resultado <- resultado + revenues(kTemp)*v^(kTemp-1)
  }
  return(medidaVPN()/resultado)
}


```

Con lo cual obtenemos un MU de `r medidaMU()`.

## 2. Análisis estocástico

### a. Análisis stress-testing para el VPN y MU

(Escoge 2 variables y realiza el stress testing)

Escogemos las variables de tasa de interés y de tabla de mortalidad y realizamos el stress testing para el VPN y MU.

Variamos primero la tasa de interés de 3% a 10% dejando los supuestos base fijos.

```{r, echo=FALSE}
rangoTasaInteres <- seq(.03, .1, .001)
tablaMortalidadEstimada <- tablaMortalidad

rangoTasaInteresVPN <- c()
rangoTasaInteresMU <- c()

# Inicialización de vectores
rangoTasaInteresVPN <- numeric(length(rangoTasaInteres))
rangoTasaInteresMU <- numeric(length(rangoTasaInteres))

for (i in seq_along(rangoTasaInteres)){
  iTasaEstimada <- rangoTasaInteres[i]
  rangoTasaInteresVPN[i] <- medidaVPN()  
  rangoTasaInteresMU[i] <- medidaMU()    
}


# Para la gráfica de VPN vs tasa de interés
ggplot() +
  geom_line(aes(x = rangoTasaInteres, y = rangoTasaInteresVPN)) +
  geom_point(aes(x = rangoTasaInteres, y = rangoTasaInteresVPN)) +
  geom_vline(aes(xintercept = 0.075), linetype="dashed", color="blue") +
  geom_vline(aes(xintercept = 0.05), linetype="dashed", color="red") +
  annotate("text", x = 0.075, y = max(rangoTasaInteresVPN), label = "Tasa Estimada") +
  annotate("text", x = 0.05, y = max(rangoTasaInteresVPN), label = "Tasa Base") +
  labs(title = "VPN vs tasa de interés", x = "Tasa de interés", y = "VPN")

# Para la gráfica de MU vs tasa de interés
ggplot() +
  geom_line(aes(x = rangoTasaInteres, y = rangoTasaInteresMU)) +
  geom_point(aes(x = rangoTasaInteres, y = rangoTasaInteresMU)) +
  geom_vline(aes(xintercept = 0.075), linetype="dashed", color="blue") +
  geom_vline(aes(xintercept = 0.05), linetype="dashed", color="red") +
  annotate("text", x = 0.075, y = max(rangoTasaInteresMU), label = "Tasa Estimada") +
  annotate("text", x = 0.05, y = max(rangoTasaInteresMU), label = "Tasa Base") +
  labs(title = "MU vs tasa de interés", x = "Tasa de interés", y = "MU")


```

Ahora variaremos la tabla de mortalidad cambiando los valores del parámetro $\alpha$. El efecto de estos cambios en la tabla se ven de esta forma:

```{r, echo=F, results=F}


beta_const = 1/4 # Valor constante para el parámetro de tasa
alphas = c(5,6,7,8,9) # Diferentes valores para alpha

# Crear un dataframe con valores de x y las densidades para cada alpha
df <- data.frame(x = rep(seq(0, 55, length.out = 1000), length(alphas)))
df$y <- unlist(lapply(alphas, function(alpha) (1 - pgamma(df$x[1:1000], shape = alpha, rate = beta_const))))
df$alpha <- factor(rep(alphas, each = 1000), labels = paste("alpha =", alphas))

ggplot(df, aes(x=x, y=y, color=alpha)) +
  geom_line() +
  labs(title = "Función de Supervivencia Gamma variando alpha",
       x = "x",
       y = "S(x)",
       color = "Valor de Alpha") +
  theme_minimal()
```

Y con lo cual los cambios en VPN y MU se ven gráficamente de la siguiente forma:

```{r, echo=FALSE}
iTasaEstimada <- .05
rangoTablaMortalidad <- seq(4,9,.1)

# Inicialización de vectores

rangoTablaMortalidadVPN <- numeric(length(rangoTablaMortalidad))

rangoTablaMortalidadMU <- numeric(length(rangoTablaMortalidad))

for (i in seq_along(rangoTablaMortalidad)){
  tablaMortalidadEstimada <- generate_mortality_table_gamma(rangoTablaMortalidad[i])
  rangoTablaMortalidadVPN[i] <- medidaVPN()  
  rangoTablaMortalidadMU[i] <- medidaMU()    
}

ggplot() +
  geom_line(aes(x = rangoTablaMortalidad, y = rangoTablaMortalidadVPN)) +
  geom_point(aes(x = rangoTablaMortalidad, y = rangoTablaMortalidadVPN)) +
  geom_vline(aes(xintercept = 8), linetype="dashed", color="blue") +
  annotate("text", x = 8, y = max(rangoTablaMortalidadVPN), label = "Tabla Estimada") +
  labs(title = "VPN vs tabla de mortalidad", x = "Tabla de mortalidad", y = "VPN")

ggplot() +
  geom_line(aes(x = rangoTablaMortalidad, y = rangoTablaMortalidadMU)) +
  geom_point(aes(x = rangoTablaMortalidad, y = rangoTablaMortalidadMU)) +
  geom_vline(aes(xintercept = 8), linetype="dashed", color="blue") +
  annotate("text", x = 8, y = max(rangoTablaMortalidadMU), label = "Tabla Estimada") +
  labs(title = "MU vs tabla de mortalidad", x = "Tabla de mortalidad", y = "MU")

```



### b. Análisis por escenarios para el VPN y MU

(Plantea 5 escenarios para realizar el análisis)

Ahora plantearemos 5 escenarios para realizar el análisis.

Los escenarios serán los siguientes:

# Descripción detallada de los escenarios:
1. Escenario 1 (Pesimista): Tasa de interés del 3% y tabla de mortalidad con alfa=4.
2. Escenario 2 (Conservador): Tasa de interés del 5% y tabla de mortalidad con alfa=6.5.
3. Escenario 3 (Estimado): Tasa de interés del 7.5% y tabla de mortalidad con alfa=8.
4. Escenario 4 (Optimista): Tasa de interés del 10% y tabla de mortalidad con alfa=9.
5.- Escenario 5 (Base): Tasa de interés del  5%  y tabla de mortalidad base con la que calculamos las reservas.

Los resultados de VPN y MU de los primeros 4 escenarios se muestran en la siguiente tabla:

```{r, echo=FALSE}
escenarios <- c("Escenario 1", "Escenario 2", "Escenario 3", "Escenario 4")
medidasEscenarios <- c("VPN", "MU")

rangoEscenariosTasa <- c(.03, .05, .075, .1)

rangoEscenariosMortalidad <- c(4, 6.5, 8, 9)

# Crear una matriz con NA (puedes reemplazar NA con cualquier otro valor inicial si lo prefieres)
wide_matrix <- matrix(NA, nrow = length(escenarios), ncol = length(medidasEscenarios), dimnames = list(escenarios, medidasEscenarios))

# Iterar sobre cada fila y columna de la matriz
for (i in 1:nrow(wide_matrix)) {
  # Convertir el valor ingresado a numérico y asignarlo a la celda correspondiente
  iTasaEstimada <- rangoEscenariosTasa[i]
  tablaMortalidadEstimada <- generate_mortality_table_gamma(rangoEscenariosMortalidad[i])

  wide_matrix[i, 1] <- medidaVPN()
  wide_matrix[i, 2] <- medidaMU()
}

# Mostrar la matriz actualizada

print(wide_matrix)

```

En el quinto escenario obviamente obtenemos MU=VPN=0

### c. Análisis por simulación

#### c.1. Hipótesis para la simulación de las variables a analizar

Elegiremos tasa de interés y tabla de mortalidad como las variables a analizar.

Realizaremos simulaciones para la tasa de interés y la tabla de mortalidad, con la finalidad de obtener una distribución de los valores que pueden obtener VPN y MU conjuntamente.

Para la tasa de interés, supondremos que sigue una distribución normal recortada en 0 con media de 7.5% y desviación estándar de 1.5%.

Para la tabla de mortalidad, supondremos que la $\alpha$ de nuestro modelo Gamma sigue una distribución normal recortada en 0.

#### c.2. Histograma de 1000 realizaciones de VPN y MU

Procedemos a mostrar los histogramas de las 1000 realizaciones estocásticas sobre tasa de interés y tabla de mortalidad de VPN y MU.

```{r, echo=FALSE}
library(truncnorm) # necesitarás esta biblioteca para generar números de una distribución normal truncada

# Simulación de la tasa de interés
simulaciones_tasa_interes <- truncnorm::rtruncnorm(1000, a = 0, mean = 0.075, sd = 0.015) # Distribución normal truncada en 0

# Simulación de alpha para la tabla de mortalidad
simulaciones_alpha <- truncnorm::rtruncnorm(1000, a = 0, mean=8, sd = 1.5) # 

#funciones auxiliares

medidaVPNdf <- function(iTasaEstimada, tablaMortalidadEstimada){
   #ktemo solo está entre 1 a n
  iTasaEstimada <<- iTasaEstimada
  tablaMortalidadEstimada <<- generate_mortality_table_gamma(tablaMortalidadEstimada)
  resultado <- medidaVPN()
  return(resultado)
}

medidaMUdf <- function(iTasaEstimada, tablaMortalidadEstimada){
  iTasaEstimada <<- iTasaEstimada
  tablaMortalidadEstimada <<- generate_mortality_table_gamma(tablaMortalidadEstimada)
  resultado <- medidaMU()
  return(resultado)
}
# Crear un dataframe con las simulaciones
df_simulaciones <- data.frame(
  TasaEstimada = simulaciones_tasa_interes,
  AlphaEstimado = simulaciones_alpha
)

# Usar mutate para agregar las medidas VPN y MU al dataframe
df_resultados <- df_simulaciones %>%
  rowwise() %>%
  mutate(
    VPN = medidaVPNdf(TasaEstimada, AlphaEstimado),
    MU = medidaMUdf(TasaEstimada, AlphaEstimado)
  )

# Histograma para VPN
ggplot(df_resultados, aes(x=VPN)) + 
  geom_histogram(fill="steelblue", color="black", bins=50, alpha=0.7) + 
  labs(title="Histograma de VPN",
       x="Valor de VPN",
       y="Frecuencia") + 
  theme_minimal()

# Histograma para MU
ggplot(df_resultados, aes(x=MU)) + 
  geom_histogram(fill="steelblue", color="black", bins=50, alpha=0.7) + 
  labs(title="Histograma de MU",
       x="Valor de MU",
       y="Frecuencia") + 
  theme_minimal()

```

#### c.3. Promedio y desviación estándar de las 1000 realizaciones de VPN y MU

Los promedios y desviación estándar son los siguientes:

```{r, echo=FALSE}
library(knitr)

# Calcular el promedio y desviación estándar
promedio_VPN <- mean(df_resultados$VPN)
desviacion_VPN <- sd(df_resultados$VPN)

promedio_MU <- mean(df_resultados$MU)
desviacion_MU <- sd(df_resultados$MU)

# Crear un dataframe con los resultados
df_resumen <- data.frame(
  Medida = c("VPN", "MU"),
  Promedio = c(promedio_VPN, promedio_MU),
  Desviacion_Estandar = c(desviacion_VPN, desviacion_MU)
)

# Imprimir la tabla en formato bonito
kable(df_resumen, caption = "Promedio y desviación estándar de las 1000 realizaciones de VPN y MU", digits = 4)

```

# Para una cartera de 100 asegurados: Fondo Total

```{r, echo=FALSE}
######-------------------------------------
#Valores observados

valoresObservados_tasaInteres <- read_excel("Valores observados.xlsx", sheet="Observados Promedio", range="A3:B28")

valoresObservados_costosPromedios <- read_excel("Valores observados.xlsx", sheet="Observados Promedio", range="D3:G29")

valoresObservados_carteraObservados <- read_excel("Valores observados.xlsx", sheet="Cartera Observados", range="A1:C101")

valoresObservados_qxPromedios <- read_excel("Valores observados.xlsx", sheet="Observados Promedio", range="I2:J103")

```

## 1. Asset-share

(Fórmula para el cálculo y valores obtenidos para toda la vigencia de la póliza) 

Utilizaremos la fórmula recursiva para calcular el Asset-share:

$$\actsymb[k+1]{\mathit{AS}}{}=\frac{[\actsymb[k]{\mathit{AS}}{}+G_{k}(1-c_{k})-e_{k}](1+i_{k,k+1})-q_{x+k}(b_{k+1}(1+propb_{k})+E_{k+1}))}{p_{x+k}}$$

```{r, echo=FALSE}
# Inicializar la función AssetShare
funcInteres <- function(kTemp){
  #kTemp solo puede ir de 0-24
  resultado <- valoresObservados_tasaInteres$'Tasa de interés efectiva anual'[kTemp+1]
  return(resultado)
}
primaPropCostos <- function(kTemp, prima){
  if(kTemp==0){
    resultado <- .6*prima
  } else if(kTemp %in% c(1,2)){
    resultado <- .8*prima}
  else if(kTemp>=3 && kTemp<=mPrimas-1){
    resultado <- .95*prima
  } else {
    resultado <- 0
  }
  return(resultado)
}
funcPrimaCostos <- function(kTemp, prima){
  if(kTemp<=mPrimas-1){
    resultado <- primaPropCostos(kTemp, prima)-valoresObservados_costosPromedios$'Costo Asociado a la Prima G'[kTemp+1]
  } else {
    resultado <- 0
  }
  return(resultado)
}

propLiquidacion <- function(kTemp){
  #kTemp es >=1
  #Se da vencidamente
  if(kTemp>=1 && kTemp<=n){
    resultado <- resultado <- 1.003*saMuerte
  } else {
    resultado <- 0
  }
 return(resultado)
}

funcMuerteCostos <- function(kTemp){
  #kTemp es >=1
  #Se da vencidamente
  if(kTemp>=1 && kTemp<=n){
    resultado <- propLiquidacion(kTemp)+valoresObservados_costosPromedios$'Costo Asociado a liquidación por Muerte'[kTemp+1]
  } else {
    resultado <- 0
  }
  return(resultado)
}

funcMortalidad <- function(kTemp){
  #kTemp es >=0
  resultado <- valoresObservados_qxPromedios$qx[xEdad+kTemp+1]
  return(resultado)
  
}

assetShare <- function(kTemp, funcInteres, funcPrimaCostos, funcMuerteCostos,funcMortalidad, prima){
  if(kTemp>=1 && kTemp<=n){
    assetShareAnterior <- assetShare(kTemp-1, funcInteres, funcPrimaCostos, funcMuerteCostos,funcMortalidad, prima)

    resultado <- ((assetShareAnterior+funcPrimaCostos(kTemp-1, primaRecargada))*(1+funcInteres(kTemp-1))-funcMortalidad(kTemp-1)*funcMuerteCostos(kTemp))/(1-funcMortalidad(kTemp-1))
  }
  else{
    resultado <- 0
  }
  return(resultado)
}

```

```{r, echo=FALSE, warning=FALSE, message=FALSE}
# Creamos los valores ASSETSHARE
library(kableExtra)


# Calcular los valores
kTemp_valores <- 0:19
assetShare_valores <- sapply(kTemp_valores, function(k) assetShare(k, funcInteres, funcPrimaCostos, funcMuerteCostos, funcMortalidad, primaRecargada))


# Crear un data.frame con los resultados
df <- data.frame(kTemp = kTemp_valores, assetShare = assetShare_valores)

print(df)



```



## 2. Estimación del Fondo Total mediante el Asset-share

(Fórmula para el cálculo y valores obtenidos para toda la vigencia de la póliza)

$$\actsymb[k]{\mathit{FT}}{}=\lx{x}[O] \actsymb[k]{\mathit{AS}}{}$$

```{r, echo=FALSE, warning=FALSE, message=FALSE}
# Creamos los valores del fondo

# Calcular los valores

kTemp_valores <- 0:19

# Inicializa lx con un valor base de 100,000
lx <- numeric(length(valoresObservados_qxPromedios$qx) + 1)
lx[1] <- 100  # o el valor base que elijas

# Calcula los valores lx utilizando la relación con qx
for(i in 2:(length(lx))) {
  lx[i] <- lx[i-1] * (1 - valoresObservados_qxPromedios$qx[i-1])
}

# Almacenar los valores lx en un dataframe
df_lx <- data.frame(lx = lx)

# Multiplicar assetShare por l_x+k
df$fondo_total <- df$assetShare * df_lx$lx[(xEdad+1):(xEdad+n+1)]

# Ver el resultado
print(df)




```

# Análisis de Rentabilidad

## 1. Utilidades

(Fórmula para el cálculo y valores obtenidos para toda la vigencia de la póliza)

```{r, echo=FALSE, warning=FALSE, message=FALSE}
utilidades <- (df$assetShare-tablaValoresPolizaAsociadosRecargada$Vx)*df_lx$lx[(xEdad+1):(xEdad+n+1)]

# Crear un dataframe con el vector de utilidades

df_utilidades <- data.frame(k = 0:(length(utilidades)-1), Utilidades = utilidades)

# Crear una tabla con kable
library(knitr)
kable(df_utilidades, caption = "Utilidades por año", format = "latex", booktabs = TRUE)

```

## 2. VPN

(Fórmula para el cálculo y valor obtenido)

```{r}

```

## 3. MU

(Fórmula para el cálculo y valor obtenido)

```{r}

```